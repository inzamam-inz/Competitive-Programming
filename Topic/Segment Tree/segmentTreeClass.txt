class SegmentTree {
      #define Lc( idx )      Idx * 2
      #define Rc( idx )      Idx * 2 + 1
      public:
            struct Node {
                  int Value;
                  int Lazy;
                  Node () {
                        this->Value = ??;
                        this->Lazy = ??;
                  }
            };
            vector < Node > SegT;
            vector < int > A;

            SegmentTree( int sz ) {
                  // need to clear!
                  SegT.resize( 4 * sz + 10 );
                  A.resize( sz + 1 );
            }

            Node Merge( Node L, Node R ) {
                  Node F;
                  F = ??
                  return F;
            }

            void Relax( int L, int R, int Idx ) {
                  //Do something

                  SegT[ Idx ].Lazy = ??; //after Relaxing
            }

            void MakeSegmentTree( int L, int R, int Idx ) {
                  if ( L == R ) {
                        SegT[ Idx ].Value = ??;
                        return;
                  }

                  int M = ( L + R ) / 2;

                  MakeSegmentTree( L, M, Lc( Idx ) );
                  MakeSegmentTree( M + 1, R, Rc( Idx ) );
                  SegT[ Idx ] = Merge( SegT[ Lc( Idx ) ], SegT[ Rc( Idx ) ] );
            }

            Node RangeQuery( int L, int R, int Idx, int l, int r ) {
                  Relax( L, R, Idx );
                  
                  Node F;

                  if ( L > r || R < l )    return F;
                  if ( L >= l && R <= r )  return SegT[ Idx ];

                  int M = ( L + R ) / 2;

                  F = Merge( RangeQuery( L, M, Lc( Idx ), l, r ), RangeQuery( M + 1, R, Rc( Idx ), l, r ) );
                  SegT[ Idx ] = Merge( SegT[ Lc( Idx ) ], SegT[ Rc( Idx ) ] ); //is it useful?

                  return F;
            }

            void RangeUpdate( int L, int R, int Idx, int l, int r, int Val ) {
                  Relax( L, R, Idx );

                  if ( L > r || R < l )    return;
                  if ( L >= l && R <= r ) {
                        // Do something
                        SegT[ Idx ].Lazy = ??;
                        Relax( L, R, Idx );
                        return;
                  }

                  int M = ( L + R ) / 2;

                  RangeUpdate( L, M, Lc( Idx ), l, r, Val );
                  RangeUpdate( M + 1, R, Rc( Idx ), l, r, Val );

                  SegT[ Idx ] = Merge( SegT[ Lc( Idx ) ], SegT[ Rc( Idx ) ] );
            }
};
